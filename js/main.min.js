'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function () {
    /**
     * Класс отвечает за отображение и хранение информации о пузырьке
     */
    var Bubble =

        /**
         *
         * @param content {int} - содержимое
         * @param position {int} - номер пузырька
         * @param parent {Object} - ссылка на контейнер
         */
            function Bubble(content, position, parent) {
            _classCallCheck(this, Bubble);

            this.element = $('<div/>', {
                class: 'bubble',
                text: content
            }).css({
                'left': 25 + 80 * position + 'px'
            }).appendTo(parent)[0];

            this.value = content;
        };

    /**
     * Главный класс
     */


    var Sort = function () {
        /**
         *
         * @param element - сслыка на элемент
         */
        function Sort(element) {
            _classCallCheck(this, Sort);

            this.element = element;
        }
        /**
         * Инициализация и отрисовка пузырьков
         */


        _createClass(Sort, [{
            key: 'init',
            value: function init() {
                this.element.empty().hide();
                $('.old-bubbles-js').remove();
                this.bubbles = [];
                for (var i = 0; i < 10; i++) {
                    var number = this._getRandomNumber(0, 999),
                        bubble = new Bubble(number, i, this.element);

                    this.bubbles.push(bubble);
                }
                this.element.prepend('<p>Сгенерированный массив:</p>');
                this.element.fadeIn();
            }

            /**
             * Функция сортировки
             * Выолняет сортировку массива, а так же заполняет цепочку промисов,
             * выполняющих анимацию
             */

        }, {
            key: 'sort',
            value: function sort() {
                var _this = this;

                this._copyContainer().then(function () {
                    _this.element.find('p').text('Идёт сортировка...');
                    var len = _this.bubbles.length,
                        promise = Promise.resolve();

                    for (var i = 0; i < len; i++) {
                        var _loop = function _loop(j) {
                            var isSwap = false,
                                $bubble1 = $(_this.bubbles[j].element),
                                $bubble2 = $(_this.bubbles[j + 1].element);

                            if (_this.bubbles[j].value > _this.bubbles[j + 1].value) {
                                var temp = _this.bubbles[j];
                                _this.bubbles[j] = _this.bubbles[j + 1];
                                _this.bubbles[j + 1] = temp;
                                isSwap = true;
                            }
                            promise = promise.then(function () {
                                return _this._animateBubbles($bubble1, $bubble2, isSwap);
                            });
                        };

                        for (var j = 0; j < len - i - 1; j++) {
                            _loop(j);
                        }
                    }
                    promise.then(function () {
                        $('.buttons__generate').removeClass('disabled');
                        _this.element.find('p').text('Отсортированный массив:');
                    });
                });
            }

            /**
             * Фукнция взаимодействия пузырьков
             * @param $bubble1 - ссылка на первый пузырёк
             * @param $bubble2 - ссылка на второй пузырёк
             * @param isSwap - нужно ли менять их местами
             * @returns {Promise} - возвращается после заверешения анимации
             * @private
             */

        }, {
            key: '_animateBubbles',
            value: function _animateBubbles($bubble1, $bubble2, isSwap) {
                var bubble1LeftOffset = $bubble1.css('left'),
                    bubble2LeftOffset = $bubble2.css('left');

                $bubble1.addClass('bubble-current');
                $bubble2.addClass('bubble-current');

                return new Promise(function (resolve) {
                    setTimeout(function () {
                        if (isSwap) {
                            $bubble1.animate({ top: '-10px' }, 150, function () {
                                $bubble1.animate({ left: bubble2LeftOffset }, 150, function () {
                                    $bubble2.animate({ top: '40px' }, 150);
                                    $bubble1.animate({ top: '40px' }, 150, function () {
                                        $bubble1.removeClass('bubble-current');
                                        $bubble2.removeClass('bubble-current');
                                        resolve();
                                    });
                                });
                                $bubble2.animate({ left: bubble1LeftOffset }, 150);
                            });
                            $bubble2.animate({ top: '90px' }, 150);
                        } else {
                            $bubble1.removeClass('bubble-current');
                            $bubble2.removeClass('bubble-current');
                            resolve();
                        }
                    }, 700);
                });
            }

            /**
             * Метод генерации числа
             * @param min - минимальное значение
             * @param max - Максимальное значение
             * @returns {number} - случайное число от min до max
             * @private
             */

        }, {
            key: '_getRandomNumber',
            value: function _getRandomNumber(min, max) {
                return Math.floor(Math.random() * (max - min) + min);
            }
        }, {
            key: '_copyContainer',
            value: function _copyContainer() {
                var originalBubbles = this.element.clone();

                originalBubbles.hide().addClass('old-bubbles-js');
                this.element.after(originalBubbles);

                return new Promise(function (resolve, reject) {
                    $('.old-bubbles-js').fadeIn(500, function () {
                        resolve();
                    });
                });
            }
        }]);

        return Sort;
    }();

    /**
     * Функция вызывается по событию document.ready
     * Вешает обработчики и инициализирует классы
     *
     */


    $(function () {
        var sort = new Sort($('.bubbles'));

        $('.buttons__generate').click(function () {
            if (!$(this).hasClass('disabled')) {
                $('.buttons__sort').removeClass('disabled');
                sort.init();
            }
        });

        $('.buttons__sort').click(function () {
            if (!$(this).hasClass('disabled')) {
                $(this).addClass('disabled');
                $('.buttons__generate').addClass('disabled');
                sort.sort();
            }
        });
    });
})();